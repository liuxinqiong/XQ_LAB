## 基础储备
通过简单的例子，看来有些基础是不懂不行了，最主要的就是正则了，在这里简单回顾一下正则

## 反斜杠的作用
使用反斜杠用来在文本字符串中插入省略号、换行符、引号和其他特殊字符

这种由反斜杠后接字母或数字组合构成的字符组合就叫做“转义序列”。

值得注意的是，转义序列会被视为单个字符。

我们常见的转义序列还有 \n 表示换行、\t 表示制表符、\r 表示回车等等。

## 转义序列
在 JavaScript 中，字符串值是一个由零或多个 Unicode 字符（字母、数字和其他字符）组成的序列。

字符串中的每个字符均可由一个转义序列表示。比如字母 a，也可以用转义序列 \u0061 表示。

> 转义序列以反斜杠 \ 开头，它的作用是告知 JavaScript 解释器下一个字符是特殊字符。

> 转义序列的语法为 \uhhhh，其中 hhhh 是四位十六进制数。

根据这个规则，我们可以算出常见字符的转义序列，以字母 m 为例：
```js
// 1. 求出字符 `m` 对应的 unicode 值
var unicode = 'm'.charCodeAt(0) // 109
// 2. 转成十六进制
var result = unicode.toString(16); // "6d"
```
值得注意的是: \n 虽然也是一种转义序列，但是也可以使用上面的方式：
```js
var unicode = '\n'.charCodeAt(0) // 10
var result = unicode.toString(16); // "a"
```

**行终结符**

在 ES5 中，有四个字符被认为是行终结符，其他的折行字符都会被视为空白。
* \u000A	换行符
* \u000D	回车符
* \u2028	行分隔符
* \u2029	段落分隔符

在 Function 构造函数的实现中，首先会将函数体代码字符串进行一次 ToString 操作，然后再检测代码字符串是否符合代码规范，在 JavaScript 中，字符串表达式中是不允许换行的。因为在模板引擎的实现中，就是使用了 Function 构造函数，如果我们在模板字符串中使用了行终结符，便有可能会出现一样的错误，所以我们必须要对这四种行终结符进行特殊的处理。

**特殊字符**
除了这四种行终结符之外，我们还要对两个字符进行处理。

一个是 \。

其实我们是想打印 '1\23'，但是因为把 \ 当成了特殊字符的标记进行处理，所以最终打印了 1。

第二个是 '。

如果我们在模板引擎中使用了 '，因为我们会拼接诸如 p.push(' ') 等字符串，因为 ' 的原因，字符串会被错误拼接，也会导致错误。

所以总共我们需要对六种字符进行特殊处理，处理的方式，就是正则匹配出这些特殊字符，然后比如将 \n 替换成 \\n，\ 替换成 \\，' 替换成 \\'，处理的代码为：
```js
var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
};

var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

var escapeChar = function(match) {
    return '\\' + escapes[match];
};
```

## replace
语法：
```
str.replace(regexp|substr, newSubStr|function)
```
replace 的第一个参数，可以传一个字符串，也可以传一个正则表达式。

第二个参数，可以传一个新字符串，也可以传一个函数。

我们重点看下传入函数的情况，直接来一个复杂的例子：
```js
function replacer(match, p1, p2, p3, offset, string) {
    // match，表示匹配的子串 abc12345#$*%
    // p1，第 1 个括号匹配的字符串 abc
    // p2，第 2 个括号匹配的字符串 12345
    // p3，第 3 个括号匹配的字符串 #$*%
    // offset，匹配到的子字符串在原字符串中的偏移量 0
    // string，被匹配的原字符串 abc12345#$*%
    return [p1, p2, p3].join(' - ');
}
var newString = 'abc12345#$*%'.replace(/([^\d]*)(\d*)([^\w]*)/, replacer); // abc - 12345 - #$*%
```

如果第一个参数是正则表达式，并且其为全局匹配模式， 那么这个方法将被多次调用，每次匹配都会被调用。

## 正则

### 正则表达式创建
* var reg = /ab+c/i;
* new RegExp('ab+c', 'i');

每个正则表达式对象都有一个 source 属性，返回当前正则表达式对象的模式文本的字符串：
```js
var regex = /fooBar/ig;
console.log(regex.source); // "fooBar"，不包含 /.../ 和 "ig"。
```

### 基本规则
* \d 就表示了匹配一个数字，等价于 [0-9]。
* \+ 号代表前面的字符必须至少出现一次（1次或多次）。
* \* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。
* ? 问号代表前面的字符最多只可以出现一次（0次、或1次）。 

/^[0-9]+abc$/
* ^ 为匹配输入字符串的开始位置。
* [0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。
* abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。

/<%=(.+?)%>/g 和 /<%=([\s\S]+?)%>/g 区别
* \s 表示匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格，\S
匹配一个非空白符，[\s\S]就表示匹配所有的内容，可是为什么我们不直接使用 . 呢？
* .匹配除行终结符之外的任何单个字符

### 惰性匹配
我们知道 x+ 表示匹配 x 1 次或多次。x?表示匹配 x 0 次或 1 次，但是 +? 是个什么鬼？

实际上如果在数量词 *、+、? 或 {}, 任意一个后面紧跟该符号（?），会使数量词变为非贪婪（ non-greedy） ，即匹配次数最小化。反之，默认情况下，是贪婪的（greedy），即匹配次数最大化。
```js
console.log("aaabc".replace(/a+/g, "d")); // dbc

console.log("aaabc".replace(/a+?/g, "d")); // dddbc
```

## 实现
与使用数组的 push ，最后再 join 的方法不同，underscore 使用的是字符串拼接的方式。

直接看代码里实现

## 来源
* [模板引擎](https://github.com/mqyqingfeng/Blog/issues/70)